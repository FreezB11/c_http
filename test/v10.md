// ============= response.c (FIXED) =============
#include <http/http.h>
#include <http/conn.h>
#include <http/utils.h>

#include <stdio.h>
#include <string.h>

SIV build_resp(conn_ctx_t *ctx, http_resp_t *res){
    // if static response, just copy
    if(res->is_static){
        memcpy(ctx->write_buf, res->body_ptr, res->body_len);
        ctx->write_total = res->body_len;
        ctx->write_pos = 0;
        return;
    }

    // dynamic response for /echo?key=value
    char *buf = ctx->write_buf;
    int pos = 0;

    // build response for echo
    pos += sprintf(buf + pos, "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n");

    // we calc the body len
    int body_s = pos + 100;
    int body_p = body_s;

    body_p += sprintf(buf + body_p, "{");
    for(int i = 0; i < ctx->req.param_count; i++){
        if(i > 0) body_p += sprintf(buf + body_p, ",");
        // FIXED: Changed "%.s" to "%.*s" for value formatting
        body_p += sprintf(buf + body_p, "\"%.*s\":\"%.*s\"",
                            ctx->req.params[i].key_len, ctx->req.params[i].key,
                            ctx->req.params[i].val_len, ctx->req.params[i].val);
    }
    body_p += sprintf(buf + body_p, "}");

    int body_len = body_p - body_s;

    // now writing the header
    pos += sprintf(buf + pos, "Content-Length: %d\r\n", body_len);
    pos += sprintf(buf + pos, "Connection: keep-alive\r\nCache-Control: no-cache\r\n\r\n");

    // moving body to the correct position
    memmove(buf + pos, buf + body_s, body_len);

    ctx->write_total = pos + body_len;
    ctx->write_pos = 0;
}

// ============= http.c (FIXED) =============
#include <http/http.h>
#include <http/utils.h>
#include <http/worker.h>

#include <stdio.h>
#include <string.h>

// helper
SIV setup_socket(int fd){
    int flags = 1;
    setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flags, sizeof(flags));
    setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &flags, sizeof(flags));

    // larger buffer (FIXED: was 5242288, should be 524288)
    int buff_size = 524288; // 512KB
    setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &buff_size, sizeof(buff_size));
    setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &buff_size, sizeof(buff_size));

    // quick ACK
    setsockopt(fd, IPPROTO_TCP, TCP_QUICKACK, &flags, sizeof(flags));

    fcntl(fd, F_SETFL, O_NONBLOCK);
}

http* CreateServer(){
    signal(SIGPIPE, SIG_IGN);
    int threads = THREAD_COUNT;
    
    // Print banner FIRST
    printf("\n");
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘  ğŸš€ HYPER-OPTIMIZED C HTTP SERVER         â•‘\n");
    printf("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    printf("â•‘  ğŸ“¡ Port: 8080                            â•‘\n");
    printf("â•‘  ğŸ”¥ Threads: %-2d                           â•‘\n", threads);
    printf("â•‘  âš¡ Optimizations:                         â•‘\n");
    printf("â•‘     â€¢ SO_REUSEPORT per thread             â•‘\n");
    printf("â•‘     â€¢ Memory pooling                      â•‘\n");
    printf("â•‘     â€¢ Pre-compiled responses              â•‘\n");
    printf("â•‘     â€¢ CPU affinity pinning                â•‘\n");
    printf("â•‘     â€¢ Zero-copy for static responses      â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("\nğŸ“Š Benchmark:\n");
    printf("   wrk -t12 -c400 -d30s http://localhost:8080/ping\n");
    printf("   wrk -t12 -c400 -d30s 'http://localhost:8080/echo?key=value'\n\n");
    fflush(stdout);
    
    conn_pool = mmap(NULL, sizeof(conn_ctx_t) * CONN_POOL_SIZE,
                     PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (conn_pool == MAP_FAILED) {
        perror("mmap");
        return NULL;
    }
    
    pthread_t thread_pool[threads];
    for (int i = 0; i < threads; i++) {
        pthread_create(&thread_pool[i], NULL, worker_thread, (void *)(intptr_t)i);
    }

    // DON'T join threads here - they run forever
    // Just return a dummy pointer
    http *dummy = (http*)1; // Non-null pointer
    return dummy;
}

// ============= conn.h (FIXED - Add forward declaration) =============
#pragma once

// Forward declarations
typedef struct http_req http_req_t;
typedef struct http_resp http_resp_t;

typedef enum {
    CONN_READING = 0,
    CONN_WRITING = 1,
    CONN_CLOSE = 2
} conn_state_t;

typedef struct {
    int fd;
    conn_state_t state;
    char *read_buf;
    char *write_buf;
    int read_total;
    int write_total;
    int write_pos;
    http_req_t req;
    http_resp_t resp;
} conn_ctx_t;

conn_ctx_t *alloc_conn();
void handle_readable(conn_ctx_t *ctx);
void handle_writable(conn_ctx_t *ctx);

// ============= http.h (FIXED - Better organization) =============
#pragma once

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <errno.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <sys/epoll.h>
#include <signal.h>
#include <netinet/tcp.h>
#include <sched.h>
#include <sys/mman.h>

#define MAX_EVENTS 8192
#define BUFFER_SIZE 16384
#define RESP_BUFFER_SIZE 32768
#define THREAD_COUNT 8
#define CONN_POOL_SIZE 16384

// Forward declarations
typedef struct conn_ctx conn_ctx_t;
typedef struct http_req http_req_t;
typedef struct http_resp http_resp_t;

// Include other headers after forward declarations
#include <http/utils.h>
#include <http/request.h>
#include <http/response.h>
#include <http/conn.h>

// Memory pool for connections (must be defined after conn_ctx_t)
extern conn_ctx_t *conn_pool;
extern int conn_pool_next;
extern pthread_mutex_t pool_mutex;

typedef struct{
    int dummy; // placeholder
} http;

void setup_socket(int fd);
http* CreateServer();
void build_resp(conn_ctx_t *ctx, http_resp_t *res);

#define HTTP_STATS 0

// ============= utils.h (FIXED - Remove conflicting macros) =============
#pragma once

// Use inline functions instead of macros for better type safety
static inline void SIV_dummy(void) {} // Remove this, just use void directly

// ============= ADDITIONAL FIX: conn.c =============
#include <http/http.h>
#include <http/conn.h>
#include <http/parse.h>
#include <http/route.h>
#include <http/response.h>

#include <stdio.h>
#include <string.h>

conn_ctx_t *alloc_conn(){
    pthread_mutex_lock(&pool_mutex);
    if(conn_pool_next >= CONN_POOL_SIZE){
        pthread_mutex_unlock(&pool_mutex);
        conn_ctx_t *ctx = calloc(1, sizeof(conn_ctx_t));
        if (ctx) {
            ctx->read_buf = malloc(BUFFER_SIZE);
            ctx->write_buf = malloc(RESP_BUFFER_SIZE);
        }
        return ctx;
    }

    conn_ctx_t *ctx = &conn_pool[conn_pool_next++];
    pthread_mutex_unlock(&pool_mutex);

    if(!ctx->read_buf){
        ctx->read_buf = malloc(BUFFER_SIZE);
        ctx->write_buf = malloc(RESP_BUFFER_SIZE);
    }
    memset(&ctx->req, 0, sizeof(http_req_t));
    memset(&ctx->resp, 0, sizeof(http_resp_t));
    ctx->read_total = 0;
    ctx->write_total = 0;
    ctx->write_pos = 0;

    return ctx;
}

void handle_readable(conn_ctx_t *ctx){
    while(1){
        int space = BUFFER_SIZE - ctx->read_total;
        if(space <= 0){
            ctx->state = CONN_CLOSE;
            return;
        }
        int n = read(ctx->fd, ctx->read_buf + ctx->read_total, space);
        if(n < 0){
            if(errno == EAGAIN || errno == EWOULDBLOCK) break;
            ctx->state = CONN_CLOSE;
            return;
        }
        if(n==0){
            ctx->state = CONN_CLOSE;
            return;
        }
        ctx->read_total += n;

        int consumed = parse_http_req(ctx, &ctx->req);
        if(consumed > 0){
            route_req(&ctx->req, &ctx->resp);
            build_resp(ctx, &ctx->resp);

            if(consumed < ctx->read_total){
                memmove(ctx->read_buf, ctx->read_buf + consumed, ctx->read_total - consumed);
            }
            ctx->read_total -= consumed;
            ctx->state = CONN_WRITING;
            break;
        }
    }
}

void handle_writable(conn_ctx_t *ctx){
    while (ctx->write_pos < ctx->write_total) {
        int remaining = ctx->write_total - ctx->write_pos;
        int n = send(ctx->fd, ctx->write_buf + ctx->write_pos, remaining, MSG_NOSIGNAL);
        
        if (n < 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) break;
            ctx->state = CONN_CLOSE;
            return;
        }
        if (n == 0) {
            ctx->state = CONN_CLOSE;
            return;
        }
        
        ctx->write_pos += n;
    }
    
    if (ctx->write_pos >= ctx->write_total) {
        ctx->write_total = 0;
        ctx->write_pos = 0;
        ctx->state = CONN_READING;
    }
}

// Compile with:
// gcc -O3 -I include -march=native -flto -pthread -D_GNU_SOURCE main.c ./src/*.c -o http